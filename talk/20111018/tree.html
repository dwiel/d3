<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="style.css"/>
    <script type="text/javascript" src="d3/d3.js"></script>
    <script type="text/javascript" src="d3/d3.layout.js"></script>
    <script type="text/javascript" src="shortcut.js"></script>
    <style type="text/css">


.node rect {
  cursor: pointer;
  fill: #fff;
  /* stroke: steelblue; */
  stroke-width: 1.5px;
}

.node text {
  font-size: 11px;
  font-family: monospace;
}

path.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

    </style>
  </head>
  <body>
    <div id="body">
      <div id="footer">
        Topology Editor
        <div class="hint">click node for menu</div>
        <div id="docs">
          <xmp>
            Mouse :

            Click on a meter for a menu of actions
            Click on a menu option to act on it

            ---------------------------------------------

            Keyboard :

            The currently selected meter has a
            green border
                
                       ~ navigation ~

                ← ↓ ↑ →      : navigate tree
                h j k l      : navigate tree
                Page Up/Down : navigate to first/last
                               sibling

                
                         ~ menus ~

                Enter        : open menu/act on menu item
                Escape       : quit menu


                        ~ actions ~

                Delete       : remove meter
                m            : change multiplier


          </xmp>
        </div>
      </div>
    </div>
    <script type="text/javascript">
/*
 * NOTE:
 * a node with a click attribute is a node that is part of a menu
 *
 * there are a few globals:
 *   selected - the currently selected node (never undefined)
 *   menu_node - the node which has a menu branching off of it, if
 *               there is a menu node; undefined otherwise.
 *   unused_nodes - a list of meters which are a part of this house, but have
 *                  not yet been used.
 */

// globals
var selected;
var menu_node;
var unused_nodes = [
  {"name" : "3"},
  {"name" : "3 A"},
  {"name" : "3 B"},
  {"name" : "3 C"}
];

var m = [20, 120, 20, 120],
    w = 1280 - m[1] - m[3],
    h = 800 - m[0] - m[2],
    i = 0,
    root;

var tree = d3.layout.tree()
    .sort(function (a, b) {
      // if a and b are meters (no click action) then sort by name
      if(a.click == undefined && b.click == undefined) { 
        return a.name > b.name;
      // if a or b are not meters, keep the order that they were added in
      } else {
        // they are equal
        return 0;
      }
    })
    .size([h, w]);

// the projection makes the edges go left-right rather than up-down
var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

// set position of the visualization
var vis = d3.select("#body").append("svg:svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

// load initial data
d3.json("flare.json", function(json) {
  root = json;
  root.x0 = h / 2;
  root.y0 = 0;
  
  selected = root;
  
  update(root);
});

function update(source) {
  // this function gets called any time a node changes
  
  // standard animation speed
  var duration = d3.event && d3.event.altKey ? 500 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();

  // Normalize for fixed-depth.
  nodes.forEach(function(d) {
    d.y = d.depth * 180;
  });

  // Update the nodes…
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) { click(d); });

  rect_width = function(d) {
    var add_chars = Math.max(d.name.length - 14, 0);
    if(add_chars > 5 && d != selected) {
      add_chars = 5;
    }
    return 110 + (add_chars * 7);
  }
  rect_stroke = function(d) {
    if(selected == d) {
      return '#76AB3B';
    } else {
      if(d.computed) {
        return "#1e384d";
      } else if(d.click) {
        return "#ccc";
      } else {
        return "steelblue";
      }
    }
  }
  nodeEnter.append("svg:rect")
      .attr("y", -12)
      .attr("height", 25)
      .style("fill",   function(d) { return d.click ? "#ccc" : "#fff"; })
      .attr("width", rect_width)
      .style("stroke", rect_stroke);

  text_text = function(d) {
    var n = d.name;
    if(n.length > 19 && d != selected) {
      n = n.substr(0, 16) + '...';
    }
    if(d.multiplier && d.multiplier != 1) {
      return n + " * " + d.multiplier;
    } else {
      return n;
    }
  }
  nodeEnter.append("svg:text")
      .attr("x", function(d) { return 7; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return "start"; })
      .text(text_text)
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("rect")
      .style("fill", function(d) { return d.click ? "#eee" : "#fff"; })
      .attr("rx", function(d) { return d.computed ? 6 : 0; })
      .attr("width", rect_width)
      // switch colors immediately, no waiting necessary
      .duration(0)
      .style("stroke", rect_stroke);

  nodeUpdate.select("text")
      .style("fill-opacity", 1)
      .text(text_text);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("rect")

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
    .transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", function(pts) {
        console.log(pts.source);
        return diagonal({
          "source" : {x: pts.source.x, y: pts.source.y + rect_width(pts.source)},
          "target" : {x: pts.target.x, y: pts.target.y + 0},
        });
      });

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// gets called on every node selection (mouse:click or keyboard:enter)
function click(d) {
  if(d.click != undefined) {
    d.click(d);
  } else {
    show_menu(d);
  }
}

// remove all elements from l for which f(e) is true
function remove(l, f) {
  var new_l = [];
  for(var i in l) {
    var e = l[i];
    if(!f(e)) {
      new_l.push(e);
    }
  }
  return new_l;
}

// hide any menu located at node d
function hide_menu() {
  menu_node.children = remove(menu_node.children, function (e) {
    return e.click != undefined;
  });
  
  // if the selected node is a child of the menu we are hiding, make the 
  // menu_node the new selected node
  if(selected.parent == menu_node || (
     selected.parent != undefined && selected.parent.parent == menu_node)) {
    selected = menu_node;
  }
  
  update(menu_node);
  
  // there is no longer any menu
  menu_node = undefined;
}

function remove_node(d) {
  // remove node d from the tree and add to the unused_nodes list
  
  var p = d.parent;
  p.children = remove(p.children, function (e) {
    return e == d;
  });
  update(p);
  update(d);
  
  unused_nodes.push(d);
  if(d.children != undefined) {
    for(var i in d.children) {
      var e = d.children[i];
      if(e.click == undefined) {
        unused_nodes.push(e);
      }
    }
  }
  
  selected = d.parent;
}

function change_multiplier(d) {
  // change the multiplier of node d
  
  var multiplier = d.multiplier;
  if(multiplier == undefined) {
    multiplier = 1;
  }
  d.multiplier = prompt("new multiplier", multiplier);
}

function show_menu(d) {
  // show a menu branching of node d
  
  // hide other menu if there is another one open
  // if there is already a menu open at this node, just close it
  if(menu_node != undefined) {
    if(menu_node == d) {
      hide_menu();
      return;
    } else {
      hide_menu();
    }
  }
  
  // initialize children attribute if it isn't already
  if(d.children == undefined) {
    d.children = [];
  }
  
  node = {"name" : "add child", "click" : function (e) {
    // if we've already expanded the add child menu, don't expand it again
    if(e.children != undefined) {
      return
    }
    
    new_node = function (n) {
      unused_nodes = remove(unused_nodes, function (e) {
        return e.name == n.name;
      });
      
      d.children.push({"name" : n.name});
      
      hide_menu();
    }
    cancel = function () {
      hide_menu();
    };
    
    e.children = [];
    
    // if there are unused nodes, list them
    if(unused_nodes.length > 0) {
      // show available (unused) nodes
      for(var i in unused_nodes) {
        e.children.push(
          {"name" : unused_nodes[i].name, "click" : new_node}
        );
      }
      
      // add computed meter menu option
      e.children.push({"name" : "new computed meter", "click" : function () {
        var new_name = prompt("new computed meter name", "");
        d.children.push({"name" : new_name, "computed" : true})
        hide_menu();
      }})

      // add cancel menu option
      e.children.push(
        {"name" : "cancel", "click" : cancel}
      );
    } else {
      // there are no unused nodes
      e.children.push(
        {"name" : "no unused nodes", "click" : cancel}
      );
    }
    selected = e.children[0];
    
    update(e);
  }}
  d.children.push(node);
  // add child node is selected by default in the menu
  selected = node;
  
  // can't remove the root node
  if(d.parent != undefined) {
    d.children.push({"name" : "remove", "click" : function () {
      remove_node(d);
    }});
  }
  
  // allow changing the multiplier
  d.children.push({"name" : "change mult", "click" : function () {
    change_multiplier(d);
    hide_menu();
  }});
  update(d);
  
  // keep track of the node menu that is open
  menu_node = d;
}

/////////
// keyboard shortcut stuff

// keyboard navigation
function right() {
  if(selected.children.length > 0) {
    selected = selected.children[0];
    update(selected);
    update(selected.parent);
  }
}
shortcut.add("right", right);
shortcut.add("l", right);

function left() {
  if(selected.parent != undefined) {
    var old = selected;
    selected = selected.parent;
    update(selected);
    update(old);
  }
}
shortcut.add("left", left);
shortcut.add("h", left);

function up() {
  var p = selected.parent;
  if(p != undefined) {
    var i = p.children.indexOf(selected) - 1;
    if(i >= 0) {
      var old = selected;
      selected = p.children[i];
      update(selected);
      update(old);
    }
  }
}
shortcut.add("up", up);
shortcut.add("k", up);

function down() {
  var p = selected.parent;
  if(p != undefined) {
    var i = p.children.indexOf(selected) + 1;
    if(i < p.children.length) {
      var old = selected;
      selected = p.children[i];
      update(selected);
      update(old);
    }
  }
}
shortcut.add("down", down);
shortcut.add("j", down);

shortcut.add("pagedown", function () {
  if(selected.parent == undefined) return;
  selected = selected.parent.children.slice(-1)[0];
  update(selected);
});
shortcut.add("pageup", function () {
  if(selected.parent == undefined) return;
  selected = selected.parent.children[0];
  update(selected);
});

// keyboard menus
shortcut.add("enter", function () {
  click(selected);
});
shortcut.add("escape", function () {
  // hide the current menu_node
  hide_menu();
});

// keyboard actions
shortcut.add("delete", function () {
  var p = selected.parent;
  remove_node(selected);
  update(selected);
  update(p);
});
shortcut.add("m", function () {
  change_multiplier(selected);
  update(selected);
});

    </script>
  </body>
</html>
