<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="style.css"/>
    <script type="text/javascript" src="d3/d3.js"></script>
    <script type="text/javascript" src="d3/d3.layout.js"></script>
    <script type="text/javascript" src="shortcut.js"></script>
    <style type="text/css">


.node rect {
  cursor: pointer;
  fill: #fff;
  /* stroke: steelblue; */
  stroke-width: 1.5px;
}

.node text {
  font-size: 11px;
  font-family: monospace;
}

path.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

    </style>
  </head>
  <body>
    <div id="body">
      <div id="footer">
        Topology Editor
        <div class="hint">click node for menu</div>
        <div id="docs">
          <xmp>
            Legend :

            - Computed meters have rounded corners and 
              a darker border

            - Measured meters have sharp corners and a 
              lighter border
            
            - Meters which are not computable have a red
              border
            
            ---------------------------------------------
            
            Mouse :

            Click on a meter for a menu of actions
            Click on a menu option to act on it
            
            Drag and drop a meter to give it a new parent

            ---------------------------------------------

            Keyboard :

            The currently selected meter has a
            green border
                
                       ~ navigation ~

                ← ↓ ↑ →      : navigate tree
                h j k l      : navigate tree
                Page Up/Down : navigate to first/last
                               sibling

                
                         ~ menus ~

                Enter        : open menu/act on menu item
                Escape       : quit menu


                        ~ actions ~

                Delete       : remove meter from the list
                               * does not delete the meter
                                 or its data
                m            : change meter multiplier
                n            : change meter name
                c            : switch meter between measured 
                               and computed


          </xmp>
        </div>
      </div>
    </div>
    <script type="text/javascript">
/*
 * NOTE:
 * a node with a click attribute is a node that is part of a menu
 *
 * there are a few globals:
 *   selected - the currently selected node (never undefined)
 *   menu_node - the node which has a menu branching off of it, if
 *               there is a menu node; undefined otherwise.
 *   unused_nodes - a list of meters which are a part of this house, but have
 *                  not yet been used.
 */

// globals
var selected;
var menu_node;
var unused_nodes = [
  {"name" : "3"},
  {"name" : "3 A"},
  {"name" : "3 B"},
  {"name" : "3 C"}
];

var m = [20, 120, 20, 120],
    w = 1280 - m[1] - m[3],
    h = 800 - m[0] - m[2],
    i = 0,
    root;

var tree = d3.layout.tree()
    .sort(function (a, b) {
      // if a or b are not meters, keep the order that they were added in
      if(a.sort == false && b.sort == false) { 
        // they are equal
        ret = 0;
      } else if (a.sort == false) {
        ret = 1;
      } else if (b.sort == false) {
        ret = -1;
      } else if (a.name == b.name) {
        ret = 0;
      } else {
        ret = a.name > b.name ? 1 : -1;
      }
      console.log(a.name + ' ' + b.name + ' ' + ret);
      return ret;
    })
    .size([h, w]);

// the projection makes the edges go left-right rather than up-down
var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

// set position of the visualization
var vis = d3.select("#body").append("svg:svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

// load initial data
d3.json("flare.json", function(json) {
  root = json;
  root.x0 = h / 2;
  root.y0 = 0;
  
  selected = root;
  
  update(root);
});

function update(source) {
  // this function gets called any time a node changes
  
  // standard animation speed
  var duration = d3.event && d3.event.altKey ? 500 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();

  computable_tree();
    
  // Normalize for fixed-depth.
  nodes.forEach(function(d) {
    d.y = d.depth * 180;
  });

  // Update the nodes…
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) { click(d); });

  rect_width = function(d) {
    var add_chars = Math.max(d.name.length - 14, 0);
    if(add_chars > 5 && d != selected) {
      add_chars = 5;
    }
    return 110 + (add_chars * 7);
  }
  rect_stroke = function(d) {
    if(selected == d) {
      return '#76AB3B';
    } else {
      if(d.click) {
        return "#ccc";
      } else if(d.computable == false) {
        return "#ff0000";
      } else if(d.computed) {
        return "#1e384d";
      } else {
        return "steelblue";
      }
    }
  }
  nodeEnter.append("svg:rect")
      .attr("y", -12)
      .attr("height", 25)
      .style("fill",   function(d) { return d.click ? "#ccc" : "#fff"; })
      .attr("width", rect_width)
      .style("stroke", rect_stroke)
      .call(d3.behavior.drag()
        .on("dragstart", function(d) {
          d.xp = 0;
          d.yp = 0;
          update(d);
        })
        .on("drag", function(d) {
          if(d == root) return;
            
          d.xp += d3.event.dx;
          d.yp += d3.event.dy;
          update(d);
            
          if(d.xp < 20 && d.xp > -20 && d.yp < 20 && d.yp > -20) {
            selected = d;
            return;
          }
          
          var best_dist = 1000000;
          var best_node;
          for(var i in nodes) {
            var n = nodes[i];
            if(n == d) continue;
            
            var dist = Math.pow((d.x + d.yp) - n.x, 2) +
                       Math.pow((d.y + d.xp) - n.y, 2);
            
            if(dist < best_dist) {
              best_dist = dist;
              best_node = n;
            }
          }
          
          // look to see if this is an illegal move
          if(!is_child(d, best_node)) {
            selected = best_node;
          } else {
            selected = d;
          }
          update(selected);
        })
        .on("dragend", function(d) {
          if(d.xp < 20 && d.xp > -20 && d.yp < 20 && d.yp > -20) {
            // not a valid move, return to where we started
            d.xp = 0;
            d.yp = 0;
            update(d);
            return;
          }
          
          // reset to wherever the tree says to go
          d.xp = 0;
          d.yp = 0;
          
          // if this is an illegal drop, redraw d and be done
          if(d.parent == selected || d == selected) {
            update(d);
            return;
          }
          
          // remove this node from its parent
          var p = d.parent;
          p.children = remove(p.children, function (e) {
            return d == e;
          });
          
          // move this node to its new parent
          if(selected.children === undefined) {
            selected.children = [];
          }
          selected.children.push(d);
          
          // redraw this node
          update(d);
        }));

  text_text = function(d) {
    var n = d.name;
    if(n.length > 19 && d != selected) {
      n = n.substr(0, 16) + '...';
    }
    if(d.multiplier && d.multiplier != 1) {
      return n + " * " + d.multiplier;
    } else {
      return n;
    }
  }
  nodeEnter.append("svg:text")
      .attr("x", function(d) { return 7; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return "start"; })
      .text(text_text)
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("rect")
      .style("fill", function(d) { return d.click ? "#eee" : "#fff"; })
      .attr("rx", function(d) { return d.computed ? 6 : 0; })
      .attr("width", rect_width)
      // switch colors immediately, no waiting necessary
      .duration(1)
      .attr("x", function(d) { return d.xp ? d.xp : 0; })
      .attr("y", function(d) { return d.yp ? d.yp -12 : -12; })
      .style("stroke", rect_stroke);

  nodeUpdate.select("text")
      .style("fill-opacity", 1)
      .text(text_text);

  nodeUpdate.select("text")
      .duration(1)
      .attr("x", function(d) { return d.xp ? 7 + d.xp : 7; })
      .attr("y", function(d) { return d.yp ? d.yp : 0; })

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("rect")

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
    .transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", function(pts) {
        return diagonal({
          "source" : {x: pts.source.x, y: pts.source.y + rect_width(pts.source)},
          "target" : {x: pts.target.x, y: pts.target.y + 0},
        });
      });

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// gets called on every node selection (mouse:click or keyboard:enter)
function click(d) {
  if(d.click != undefined) {
    d.click(d);
  } else {
    show_menu(d);
  }
}

// remove all elements from l for which f(e) is true
function remove(l, f) {
  var new_l = [];
  for(var i in l) {
    var e = l[i];
    if(!f(e)) {
      new_l.push(e);
    }
  }
  return new_l;
}

// hide any menu located at node d
function hide_menu() {
  menu_node.children = remove(menu_node.children, function (e) {
    return e.click != undefined;
  });
  
  // if the selected node is a child of the menu we are hiding, make the 
  // menu_node the new selected node
  if(selected.parent == menu_node || (
     selected.parent != undefined && selected.parent.parent == menu_node)) {
    selected = menu_node;
  }
  
  update(menu_node);
  
  // there is no longer any menu
  menu_node = undefined;
}

function is_child(p, c) {
  if(p.children == undefined) return false;
  for(var i in p.children) {
    var child = p.children[i];
    if(child == c) return true;
    if(is_child(child, c)) return true;
  }
  return false;
}

function toggle_computed(d) {
  d.computed = !d.computed;
}

function remove_node(d) {
  // remove node d from the tree and add to the unused_nodes list
  
  var p = d.parent;
  p.children = remove(p.children, function (e) {
    return e == d;
  });
  update(p);
  update(d);
  
  unused_nodes.push(d);
  if(d.children != undefined) {
    for(var i in d.children) {
      var e = d.children[i];
      if(e.click == undefined) {
        unused_nodes.push(e);
      }
    }
  }
  
  selected = d.parent;
}

function change_multiplier(d) {
  // change the multiplier of node d
  
  var multiplier = d.multiplier;
  if(multiplier == undefined) {
    multiplier = 1;
  }
  d.multiplier = prompt("new multiplier", multiplier);
}

function change_name(d) {
  // change the name of node d
  
  d.name = prompt("new name", d.name);
  update(d);
}

function show_menu(d) {
  // show a menu branching of node d
  
  // hide other menu if there is another one open
  // if there is already a menu open at this node, just close it
  if(menu_node != undefined) {
    if(menu_node == d) {
      hide_menu();
      return;
    } else {
      hide_menu();
    }
  }
  
  // initialize children attribute if it isn't already
  if(d.children == undefined) {
    d.children = [];
  }
  
  node = {"name" : "add child", "click" : function (e) {
    // if we've already expanded the add child menu, don't expand it again
    if(e.children != undefined) {
      return
    }
    
    new_node = function (n) {
      unused_nodes = remove(unused_nodes, function (e) {
        return e.name == n.name;
      });
      
      d.children.push({"name" : n.name});
      
      hide_menu();
    }
    cancel = function () {
      hide_menu();
    };
    
    e.children = [];
    
    // if there are unused nodes, list them
    if(unused_nodes.length > 0) {
      // show available (unused) nodes
      for(var i in unused_nodes) {
        e.children.push(
          {"name" : unused_nodes[i].name, "click" : new_node}
        );
      }
      
      // add computed meter menu option
      e.children.push({
        "name" : "new computed meter",
        "sort" : false,
        "click" : function () {
          var new_name = prompt("new computed meter name", "");
         d.children.push({"name" : new_name, "computed" : true})
          hide_menu();
        }
      })

      // add cancel menu option
      e.children.push(
        {"name" : "cancel", "sort" : false, "click" : cancel}
      );
    } else {
      // there are no unused nodes
      e.children.push(
        {"name" : "no unused nodes", "sort" : false, "click" : cancel}
      );
    }
    selected = e.children[0];
    
    update(e);
  }}
  d.children.push(node);
  // add child node is selected by default in the menu
  selected = node;
  
  // allow changing the multiplier
  d.children.push({
    "name" : "change mult",
    "sort" : false,
    "click" : function () {
      change_multiplier(d);
      hide_menu();
    }
  });
  update(d);
  
  // allow changing the name
  d.children.push({
    "name" : "change name",
    "sort" : false,
    "click" : function () {
      change_name(d);
      hide_menu();
    }
  });
  
  // toggle computed
  d.children.push({
    "name" : "toggle computed",
    "sort" : false,
    "click" : function () {
      toggle_computed(d);
      hide_menu();
    }
  });
  
  // can't remove the root node
  if(d.parent != undefined) {
    d.children.push({
      "name" : "remove",
    "sort" : false,
      "click" : function () {
        remove_node(d);
      }
    });
  }
  
  update(d);

  // keep track of the node menu that is open
  menu_node = d;
}

/////////
// keyboard shortcut stuff

// keyboard navigation
function right() {
  if(selected.children.length > 0) {
    selected = selected.children[0];
    update(selected);
    update(selected.parent);
  }
}
shortcut.add("right", right);
shortcut.add("l", right);

function left() {
  if(selected.parent != undefined) {
    var old = selected;
    selected = selected.parent;
    update(selected);
    update(old);
  }
}
shortcut.add("left", left);
shortcut.add("h", left);

function up() {
  var p = selected.parent;
  if(p != undefined) {
    var i = p.children.indexOf(selected) - 1;
    if(i >= 0) {
      var old = selected;
      selected = p.children[i];
      update(selected);
      update(old);
    }
  }
}
shortcut.add("up", up);
shortcut.add("k", up);

function down() {
  var p = selected.parent;
  if(p != undefined) {
    var i = p.children.indexOf(selected) + 1;
    if(i < p.children.length) {
      var old = selected;
      selected = p.children[i];
      update(selected);
      update(old);
    }
  }
}
shortcut.add("down", down);
shortcut.add("j", down);

shortcut.add("pagedown", function () {
  if(selected.parent == undefined) return;
  selected = selected.parent.children.slice(-1)[0];
  update(selected);
});
shortcut.add("pageup", function () {
  if(selected.parent == undefined) return;
  selected = selected.parent.children[0];
  update(selected);
});

// keyboard menus
shortcut.add("enter", function () {
  click(selected);
});
shortcut.add("escape", function () {
  // hide the current menu_node
  hide_menu();
});

// keyboard actions
shortcut.add("delete", function () {
  var p = selected.parent;
  remove_node(selected);
  update(selected);
  update(p);
});
shortcut.add("m", function () {
  change_multiplier(selected);
  update(selected);
});
shortcut.add("n", function () {
  change_name(selected);
  update(selected);
});
shortcut.add("c", function () {
  toggle_computed(selected);
  update(selected);
});

/* go through the tree and mark nodes as either computable or not.
 * computable nodes will show up red and indicate an invalid configuration.
 *
 * design:
 * at first it seemed easiest to have computable_tree use a recursive walk
 * through the tree with some basic logic which could determine if each node
 * was computable as it traversed the tree.  This however got too complicated
 * because the logic to determine if a node is computable can require
 * knowledge of the entire tree.  Managing this information and logic flow
 * became complex and confusing, (though potentially optimially effiecient.)
 * 
 * Instead, the current design is used for its simplicity.  First each node
 * is marked as not computable.  We then add facts to the system one at a 
 * time, recursively propigating the implications of this knowledge at each
 * step.
 * 
 * mark(d) is used to assert that a node is computable.
 * the initially known information is that all nodes which are measured
 * directly (not computed) are computable.  All other nodes which are
 * computable are infered from these measured nodes.
 * 
 */
function computable_tree() {
  nodes = tree.nodes(root);
  
  // mark all nodes as not computable
  nodes.forEach(function(d) {
    d.computable = false;
  });

  // mark all nodes which are not computed and not part of a menu as
  // computable
  nodes.forEach(function(d) {
    if(!d.computed && !d.click) {
      mark(d);
    }
  });
}

/* helper for mark;
 * return a list of nodes in ds which are not currently known to be
 * computable
 */
function uncomputable_nodes(ds) {
  var ret = [];
  for(var i in ds) {
    var d = ds[i];
    if(!d.computable) {
      ret.push(d);
    }
  }
  
  return ret;
}

// mark a node as computable and recursively check to see if this new knowledge
// means we should mark other nodes as computable
function mark(d) {
  d.computable = true;
  
  var p = d.parent;
  if(p) {
    // see if a sibling can be computed from its parent and siblings
    if(p.computable) {
      uncomputable_siblings = uncomputable_nodes(p.children);
      if(uncomputable_siblings.length == 1) {
        // this sibling's parent and all of its siblings are computable
        // so it is computable too.
        mark(uncomputable_siblings[0]);
      }
    // see if the parent can now be computed from its children
    } else {
      if(uncomputable_nodes(p.children).length == 0) {
        // the parent's children are all computable so it is too
        mark(p);
      }
    }
  } else {
    // we are marking the root.  check to see if one of its children
    // can now be computed
    uncomputable_children = uncomputable_nodes(d.children);
    if(uncomputable_children.length == 1) {
      // this sibling's parent and all of its siblings are computable
      // so it is computable too.
      mark(uncomputable_children[0]);
    }
  }
}
    </script>
  </body>
</html>
