<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="style.css"/>
    <script type="text/javascript" src="d3/d3.js"></script>
    <script type="text/javascript" src="d3/d3.layout.js"></script>
    <script type="text/javascript" src="shortcut.js"></script>
    <style type="text/css">


.node rect {
  cursor: pointer;
  fill: #fff;
  /* stroke: steelblue; */
  stroke-width: 1.5px;
}

.node text {
  font-size: 11px;
}

path.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

    </style>
  </head>
  <body>
    <div id="body">
      <div id="footer">
        Topology Editor
        <div class="hint">click node for menu</div>
      </div>
    </div>
    <script type="text/javascript">

var m = [20, 120, 20, 120],
    w = 1280 - m[1] - m[3],
    h = 600 - m[0] - m[2],
    i = 0,
    root;

var selected;

var tree = d3.layout.tree()
    .size([h, w]);

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var vis = d3.select("#body").append("svg:svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

d3.json("flare.json", function(json) {
  root = json;
  root.x0 = h / 2;
  root.y0 = 0;
  
  selected = root;
  
  update(root);
});

function update(source) {
  var duration = d3.event && d3.event.altKey ? 500 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();

  // Normalize for fixed-depth.
  nodes.forEach(function(d) {
    d.y = d.depth * 180;
  });

  // Update the nodes…
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) { click(d); });

  nodeEnter.append("svg:rect")
      .attr("y", -15)
      .attr("width", 100)
      .attr("height", 30)
      .style("fill",   function(d) { return d.click ? "#ccc" : "#fff"; })
      .style("stroke", function(d) {
        if(selected == d) {
          return '#76AB3B';
        } else {
          return d.click ? "#ccc" : "steelblue" 
        }
      });

  nodeEnter.append("svg:text")
      .attr("x", function(d) { return 12; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return "start"; })
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("rect")
      .style("fill", function(d) { return d.click ? "#eee" : "#fff"; })
      .style("stroke", function(d) {
        if(selected == d) {
          return '#76AB3B';
        } else {
          return d.click ? "#ccc" : "steelblue" 
        }
      });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("rect")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
    .transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

function add_node() {
  root.children.push({"name" : "test"}); 
  update(root);
}

function click(d) {
  if(d.click != undefined) {
    d.click(d);
  } else {
    show_menu(d);
  }
}

function remove_element(l, e) {
  while(1) {
    var i = l.indexOf(e);
    if(i == -1) {
      break;
    } else {
      l.splice(l, i);
    }
  }
}

function remove(l, f) {
  var new_l = [];
  for(var i in l) {
    var e = l[i];
    if(!f(e)) {
      new_l.push(e);
    }
  }
  return new_l;
}

function hide_menu(d) {
  d.children = remove(d.children, function (e) {
    return (e.name == 'add child') || (e.name == 'remove')
  });
  update(d);
  last_d = undefined;
}

var unused_nodes = [
  {"name" : "3"},
  {"name" : "3 A"},
  {"name" : "3 B"},
  {"name" : "3 C"}
];

var last_d;
function show_menu(d) {
  if(last_d != undefined) {
    if(last_d == d) {
      hide_menu(last_d);
      return;
    } else {
      hide_menu(last_d);
    }
  }
  
  if(d.children == undefined) {
    d.children = [];
  }
  node = {"name" : "add child", "click" : function (e) {
    new_node = function (n) {
      unused_nodes = remove(unused_nodes, function (e) {
        return e.name == n.name;
      });
      
      d.children.push({"name" : n.name});
      
      hide_menu(d);
      update(d);
      
      selected = d;
    }
    cancel = function () {
      hide_menu(d);
      update(d);
      selected = d;
    };
    
    if(e.children == undefined) {
      e.children = [];
    }
    
    if(unused_nodes.length > 0) {
      // show available (unused) nodes
      for(var i in unused_nodes) {
        e.children.push(
          {"name" : unused_nodes[i].name, "click" : new_node}
        );
      }
      
      // add cancel menu option
      e.children.push(
        {"name" : "cancel", "click" : cancel}
      );
    } else {
      e.children.push(
        {"name" : "no unused nodes", "click" : cancel}
      );
    }
    selected = e.children[0];
    
    update(e);
  }}
  d.children.push(node);
  selected = node;
  
  if(d.parent != undefined) {
    d.children.push({"name" : "remove", "click" : function () {
      var p = d.parent;
      p.children = remove(p.children, function (e) {
        return e == d;
      });
      update(p);
      update(d);
      
      unused_nodes.push(d);
      if(d.children != undefined) {
        for(var i in d.children) {
          var e = d.children[i];
          if(e.click == undefined) {
            unused_nodes.push(e);
          }
        }
      }
      
      selected = d.parent;
    }});
  }
  update(d);
  
  last_d = d;
}

// keyboard shortcut stuff
shortcut.add("right", function() {
  if(selected.children.length > 0) {
    selected = selected.children[0];
    update(selected);
    update(selected.parent);
  }
});
shortcut.add("left", function () {
  if(selected.parent != undefined) {
    var old = selected;
    selected = selected.parent;
    update(selected);
    update(old);
  }
});
shortcut.add("up", function () {
  var p = selected.parent;
  if(p != undefined) {
    var i = p.children.indexOf(selected) - 1;
    if(i >= 0) {
      var old = selected;
      selected = p.children[i];
      update(selected);
      update(old);
    }
  }
});
shortcut.add("down", function () {
  var p = selected.parent;
  if(p != undefined) {
    var i = p.children.indexOf(selected) + 1;
    if(i < p.children.length) {
      var old = selected;
      selected = p.children[i];
      update(selected);
      update(old);
    }
  }
});
shortcut.add("enter", function () {
  click(selected);
});
shortcut.add("escape", function () {
  hide_menu(selected);
  if(selected.parent != undefined) {
    hide_menu(selected.parent);
    selected = selected.parent;
  }
  if(selected.parent != undefined) {
    hide_menu(selected.parent);
    selected = selected.parent;
  }
});

    </script>
  </body>
</html>
